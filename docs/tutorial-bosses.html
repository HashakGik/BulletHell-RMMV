<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Tutorial: Creating a boss</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Tutorial: Creating a boss</h1>

    <section>

<header>
    

    <h2>Creating a boss</h2>
</header>

<article>
    <p>In this tutorial we are going to create two bosses: a simple <code>orbiter</code> enemy <em>promoted</em> to boss and a more complicated example.</p>
<p>The engine considers bosses every enemy spawned by a generator with the parameter flag <code>boss</code> set to <code>true</code>.
When one or more of these generators becomes active, an health bar will be shown on screen and will show the <strong>total</strong> health of the spawned enemies.</p>
<p>A boss generator doesn't have to set any of the <code>sync</code> or <code>stop</code> flags (see <a href="tutorial-mechanics.html">Game Mechanics</a>), but it's usually a good idea to synchronise the stage.</p>
<p>For both bosses on this tutorial, we are going to use a custom charset. Each frame is 777x440 pixels, but the hitbox for each enemy will be smaller.</p>
<p><img src="$Bosses.png" alt="Bosses charset"></p>
<h3>Upgrading an enemy</h3>
<p>Let's start by creating a normal generator spawning a single <code>orbiter</code> enemy and let's set our custom charset.</p>
<p><img src="orbiterboss1.png" alt="Orbiter enemy"></p>
<p>Since each of the charset's frames show different monsters, it's a good idea to disable the frame animation. We'll resize the hitbox as well in order to avoid hitting the enemy when shooting against transparent pixels of the frame.</p>
<p><img src="orbiterboss2.png" alt="Orbiter enemy with hitbox"></p>
<p>So far, we've made a <strong>normal</strong> enemy with a big sprite: let's turn it into a boss.</p>
<p><img src="orbiterboss3.png" alt="Orbiter boss"></p>
<p>Finally let's tweak some other parameters: we want our boss to have a decent amount of hit points after all, and maybe bullets different than normal enemies as well.</p>
<p><img src="orbiterboss.png" alt="Orbiter boss completed"></p>
<p>Our complete boss will look like this.</p>
<p><img src="orbiterboss.gif" alt="Orbiter boss on stage"></p>
<h3>Creating a custom boss</h3>
<p>So far, we were just playing around. It's time to get serious, be aware that this part of the tutorial is not for the faint of heart.</p>
<p>We are going to create a <code>Darklord</code> boss with three different shooting patterns and a complex behaviour.
We are, conceptually, going to create a new enemy (in the same way as <a href="tutorial-enemies_js.html">Creating new enemies</a>), but the <a href="BHell.BHell_Enemy_Base.html#update"><code>BHell.BHell_Enemy_Base#update</code></a> method (as well as some others) will be heavily modified.</p>
<p>Since handling the boss' behaviour is a complicated process, we will use a <em>divide et impera</em> approach and tackle one aspect of the behaviour at the time, putting everything together at the end.</p>
<h4>Movement</h4>
<p>Let's say we want our boss to slowly move left and right without leaving the screen.
To achieve this behaviour, we can use either <a href="BHell.BHell_Mover_Bounce.html"><code>BHell.BHell_Mover_Bounce</code></a> or <a href="BHell.BHell_Mover_Harmonic.html"><code>BHell.BHell_Mover_Harmonic</code></a>, by carefully choosing the right values for their parameters.</p>
<p>Since <code>Bounce</code> requires fewer parameters, we will choose it.</p>
<p>We want our boss to start moving from the center of the screen and at a height of 200 pixels, so it's entirely on screen.
We also want it not to leave the screen, so the mover's <code>width</code> and <code>height</code> parameters will be set to the boss' hitbox.
Finally we want it to move only along the horizontal axis, so we will set the <code>angle</code> parameter to either 0 (initial movement to the right) or <code>Math.PI / 2</code> (initial movement to the left).</p>
<pre><code>this.mover = new my.BHell_Mover_Bounce(Graphics.width / 2, 200, 0, this.hitboxW, this.hitboxH);
</code></pre>
<h4>Emitters</h4>
<p>Unlike normal enemies, this boss' sprite is huge, so it's a good idea <strong>not</strong> to spawn bullets from the center.</p>
<p>For this tutorial, let's say we want our boss to shoot from these positions:</p>
<p><img src="darklord_emitters.png" alt="Darklord emitters"></p>
<p>The coordinates (referred to the boss' center) are the following:</p>
<ul>
<li>Left wing: <code>-160, -118</code></li>
<li>Right wing:  <code>152, -134</code></li>
<li>Left hand: <code>-46, -68</code></li>
<li>Right hand: <code>100, -68</code></li>
<li>Left claw: <code>-98, 100</code></li>
<li>Right claw: <code>127, 106</code></li>
<li>Forehead:  <code>42, -82</code></li>
</ul>
<p>For simplicity's sake let's say we want our emitters to be symmetric, so let's establish the following:</p>
<ul>
<li>Left and right wing will fire streaks of bullets to the side of the player, preventing it to escape:</li>
</ul>
<p><img src="darklord_wings.gif" alt="Darklord wings"></p>
<ul>
<li>Left and right hands will fire circles of bullets which will fill the screen:</li>
</ul>
<p><img src="darklord_hands.gif" alt="Darklord hands"></p>
<ul>
<li>Left and right claws will fire swirls rotating in opposite directions:</li>
</ul>
<p><img src="darklord_claws.gif" alt="Darklord claws"></p>
<ul>
<li>The forehead won't shoot any bullet, instead it will spawn some <code>Probe</code> enemies:</li>
</ul>
<p><img src="darklord_forehead.gif" alt="Darklord forehead"></p>
<p>Let's consider each of these four as if they were a single enemy.</p>
<h5>Forehead</h5>
<p>We are going to make our forehead spawn a new <code>Probe</code> enemy every three seconds (180 frames).
In order to do so, we need a frame counter.</p>
<pre><code>BHell_Enemy_Darklord.prototype.initializeForehead = function () {
    this.foreheadCounter = 0;
};
</code></pre>
<p>Since we are not using any generator, we need to manually set each of the enemy parameter by hand.
Since our forehead &quot;emitter&quot; is located at <code>42, -82</code>, our enemy will be spawned at <code>this.x + 42, this.y - 82</code>.</p>
<p><strong>Important</strong>: remember that the JSON parameters are read only by <a href="BHell.BHell_Generator.html"><code>BHell.BHell_Generator</code></a>, so if you omit some parameter, the default value will be the one set inside the <code>BHell_Enemy_*</code> class we are using (<a href="BHell.BHell_Enemy_Probe.html"><code>BHell.BHell_Enemy_Probe</code></a> in this case), <strong>not</strong> the one in the JSON.</p>
<pre><code>BHell_Enemy_Darklord.prototype.updateForehead = function() {
    // Spawn a probe enemy every 3 seconds.
    this.foreheadCounter = (this.foreheadCounter + 1) % 180;

    if (this.foreheadCounter === 0) {
        // Since no generator is used, we need to set the image parameters by hand as well.
        var image = {&quot;characterName&quot;:&quot;Evil&quot;,&quot;direction&quot;:2,&quot;pattern&quot;:0,&quot;characterIndex&quot;:6};
        var params = {};
        params.animated = true;
        params.aim = true;
        params.bullet = {};
        params.bullet.frame = 2;
        my.controller.enemies.push(new my.BHell_Enemy_Probe(this.x + 42, this.y - 82, image, params, this.parent, my.controller.enemies));
    }
};
</code></pre>
<h5>Hands</h5>
<p>Our boss' hands will spawn a circle of bullets every five seconds.
To achieve this behaviour, all we need to do is to create a <a href="BHell.BHell_Emitter_Spray.html"><code>BHell.BHell_Emitter_Spray</code></a> covering a full circle and with a period of <code>300</code>.</p>
<p>Once everything is done, we can tweak the other parameters in order to adjust the dodging difficulty of the pattern.
For the time being, let's assume <code>n = 45</code> and <code>bullet.speed = 0.5</code>.</p>
<pre><code>BHell_Enemy_Darklord.prototype.initializeHands = function (parent) {
    var handsParams = {};
    handsParams.bullet = {};
    handsParams.bullet.speed = 0.5;
    handsParams.bullet.index = 0;
    handsParams.bullet.frame = 0;
    handsParams.bullet.direction = 2;
    handsParams.period = 300;
    handsParams.a = 0;
    handsParams.b = 2 * Math.PI;
    handsParams.n = 45;
    this.handsEmitters = [];
    this.handsEmitters.push(new my.BHell_Emitter_Spray(0, 0, handsParams, parent, my.enemyBullets));
    this.handsEmitters.push(new my.BHell_Emitter_Spray(0, 0, handsParams, parent, my.enemyBullets));
    this.handsEmitters[0].offsetX = -46;
    this.handsEmitters[0].offsetY = -68;
    this.handsEmitters[1].offsetX = 100;
    this.handsEmitters[1].offsetY = -60;
};
</code></pre>
<p>Since everything is handled by the emitter (we want our hands to shoot periodically, not any strange stuff, like the boss' forehead behaviour), the <code>update</code> method is trivial:</p>
<pre><code>BHell_Enemy_Darklord.prototype.updateHands = function() {
    this.shoot(this.handsEmitters, true);
};
</code></pre>
<h5>Claws</h5>
<p>We want our claws to shoot some rotating bullets, but since a continuous streak would be undodgeable, we want to alternate between three seconds of shooting and two seconds of waiting (for a total of five seconds, or 300 frames).</p>
<p>The implementation of rotating bullets is the same as <a href="BHell.BHell_Enemy_Swirler.html"><code>BHell.BHell_Enemy_Swirler</code></a>: a <code>BHell.Bhell_Emitter_Spray</code> will shoot constantly, but between each shot the <code>angle</code> parameter will be updated.</p>
<p>To implement the on and off behaviour we need a time counter, the emitters have a very low <code>period</code> in order to achieve a continuous streak.</p>
<pre><code>BHell_Enemy_Darklord.prototype.initializeClaws = function (parent) {
    var clawsParams = {};
    clawsParams.bullet = {};
    clawsParams.bullet.speed = 1;
    clawsParams.bullet.index = 0;
    clawsParams.bullet.frame = 2;
    clawsParams.bullet.direction = 2;
    clawsParams.period = 5;
    clawsParams.a = Math.PI;
    clawsParams.b = 3 * Math.PI;
    clawsParams.n = 5;
    
    this.clawsEmitters = [];
    this.clawsEmitters.push(new my.BHell_Emitter_Spray(0, 0, clawsParams, parent, my.enemyBullets));
    this.clawsEmitters.push(new my.BHell_Emitter_Spray(0, 0, clawsParams, parent, my.enemyBullets));
    this.clawsEmitters[0].offsetX = -98;
    this.clawsEmitters[0].offsetY = 100;
    this.clawsEmitters[1].offsetX = 127;
    this.clawsEmitters[1].offsetY = 106;
    this.clawsCounter = 0;
};
</code></pre>
<p>Unlike our boss' hands, the <code>update</code> method will be slightly more complicated:</p>
<ul>
<li>our counter should reset every five seconds (300 frames),</li>
<li>the emitters should shoot for the first three seconds (180 frames) of the counter,</li>
<li>when the counter is reset we want to reset the rotation angles as well (in order to make the pattern more predictable),</li>
<li>we want our left claw to swirl clockwise and our right one to swirl counterclockwise.</li>
</ul>
<p>Our claws' update method looks like this:</p>
<pre><code>BHell_Enemy_Darklord.prototype.updateClaws = function() {
    if (this.clawsCounter === 0) {
        this.clawsEmitters[0].a = Math.PI;
        this.clawsEmitters[0].b = 3 * Math.PI;
        this.clawsEmitters[1].a = 0;
        this.clawsEmitters[1].b = 2 * Math.PI;
    }
    this.shoot(this.clawsEmitters, this.clawsCounter &lt; 180);

    this.clawsEmitters[0].a += 0.004;
    this.clawsEmitters[0].b += 0.004;
    this.clawsEmitters[1].a -= 0.004;
    this.clawsEmitters[1].b -= 0.004;

    this.clawsCounter = (this.clawsCounter + 1) % 300;
};
</code></pre>
<h5>Wings</h5>
<p>Our wings should shoot a continuous streak of bullets, aimed left (for the left wing) and right (for the right wing) of the player, in order to limit its movements.</p>
<p>In order to achieve this, we are going to use two <a href="BHell.BHell_Emitter_Angle.html"><code>BHell.BHell_Emitter_Angle</code></a> with the <code>aim</code> and <code>alwaysAim</code> parameters set to true and the <code>aimX</code> parameter set to 100 pixels (with a different sign for each emitter).</p>
<p>If the bullet speed were too fast, we would never be able to confine the player (since the aiming would be fast enough to follow every movement). In order to <em>lag</em> the aiming behaviour, all we need to do is to set <code>bullet.speed</code> to a reasonably low value (e.g. one pixel per frame).</p>
<pre><code>BHell_Enemy_Darklord.prototype.initializeWings = function (parent) {
    var wingsParams = {};
    wingsParams.bullet = {};
    wingsParams.bullet.speed = 1;
    wingsParams.bullet.index = 0;
    wingsParams.bullet.frame = 2;
    wingsParams.bullet.direction = 8;
    wingsParams.period = 5;
    wingsParams.alwaysAim = true;
    wingsParams.aim = true;
    this.wingsEmitters = [];
    this.wingsEmitters.push(new my.BHell_Emitter_Angle(0, 0, wingsParams, parent, my.enemyBullets));
    this.wingsEmitters.push(new my.BHell_Emitter_Angle(0, 0, wingsParams, parent, my.enemyBullets));
    this.wingsEmitters[0].offsetX = 152;
    this.wingsEmitters[0].offsetY = -134;
    this.wingsEmitters[1].offsetX = -160;
    this.wingsEmitters[1].offsetY = -118;
    this.wingsEmitters[0].aimX = 100;
    this.wingsEmitters[0].alwaysAim = true;
    this.wingsEmitters[1].alwaysAim = true;
    this.wingsEmitters[1].aimX = -100;
};
</code></pre>
<p>Just like our boss' hands, updating our wings is a trivial matter:</p>
<pre><code>BHell_Enemy_Darklord.prototype.updateWings = function() {
    this.shoot(this.wingsEmitters,true);
};    
</code></pre>
<h4>Finite state machine</h4>
<p>If our boss were to shoot from all of its emitters at once we would incur into two main problems:</p>
<ul>
<li>The bullet patterns would be too chaotic and make it difficult for the player to dodge them,</li>
<li>The boss would lack <em>character</em> and look just like an overpowered, but still boring, enemy.</li>
</ul>
<p>To solve these problems we simply need to <em>change</em> our boss' behaviour from time to time, allowing it to perform not a single, complicated and almost undodgeable, shooting pattern, but to choose from many different (and way more dodgeable) ones.</p>
<p>A <a href="http://en.wikipedia.org/wiki/Finite_state_machine">finite state machine</a> is an entity that can be in one of many <em>states</em> (which determine its behaviour) and can <em>transit</em> from one state to another in response to stimuli (either internal or external).</p>
<p>Many everyday &quot;things&quot; are finite state machines, allow me to use a vending machine to better exemplify the concept. We can consider a vending machine as something with the following states:</p>
<ol>
<li>Waiting for a coin: in this state none of the buttons work and no item is delivered to the user,</li>
<li>Waiting for input: in this state the buttons are enabled, but no item is delivered yet,</li>
<li>Delivering: in this state buttons are disabled again and the selected item is being delivered.</li>
</ol>
<p>The <em>transitions</em> between these states are the following:</p>
<ul>
<li>If the machine is in state 1 and a coin is inserted (external stimulus), go to state 2,</li>
<li>If the machine is in state 2 and a button is pressed (external stimulus), go to state 3,</li>
<li>If the machine is in state 2 and a timeout (internal stimulus) expires (because the user didn't press any button), go to state 1 (and possibly return the coin),</li>
<li>If the machine is in state 3 and the item is delivered (internal stimulus), go to state 1.</li>
</ul>
<p>From the example above, we can see the <em>future</em> state (or behaviour) of our system depends on two things:</p>
<ol>
<li>The <em>current</em> state (behaviour),</li>
<li>The stimulus which the system receives.</li>
</ol>
<p>Let's return to our boss, some of the internal stimuli it can receive and an example of associated behaviour could be:</p>
<ul>
<li>Time: after ten seconds the boss could change its shooting pattern,</li>
<li>Current hit points: if its life is low it may shoot more aggressively,</li>
<li>A combination of time and hit points: if it looses too many hit points too quickly, it may become stunned,</li>
<li>Position: for example, if it's outside the screen it won't shoot,</li>
<li>etc.</li>
</ul>
<p>Some of the external stimuli, on the other hand, might be:</p>
<ul>
<li>Player position: if the player is directly below, the boss may try to ram it,</li>
<li>Player attacks: if the player is throwing a bomb, the boss may become invincible,</li>
<li>Player death: the boss might laugh,</li>
<li>Number of other enemies on screen: the boss might decide not to shoot until the other enemies are dispatched,</li>
<li>etc.</li>
</ul>
<p><strong>Note</strong>: In this tutorial we will focus on the <em>shooting behaviour</em> (and some fancy stuff like sound effects and explosions), but you can customise every aspect of your bosses (including movement and appearance).</p>
<p>For our boss we want to implement the following behaviours:</p>
<ul>
<li><code>started</code>: the boss won't shoot,</li>
<li><code>pattern 1</code>: the boss will shoot from hands and claws,</li>
<li><code>pattern 2</code>: the boss will shoot from hands and wings,</li>
<li><code>pattern 3</code>: the boss will spawn <code>probes</code> from the forehead,</li>
<li><code>stunned</code>: the boss won't shoot nor move,</li>
<li><code>waiting</code>: the boss won't shoot,</li>
<li><code>dying</code>: the boss won't shoot nor move and will spawn multiple explosions before disappearing.</li>
</ul>
<p>We also want the following transitions from one state to another:</p>
<ul>
<li><code>started &gt; pattern 1</code>: when the boss reaches its starting position (we also want it to play a growling sound effect),</li>
<li><code>pattern 1 &gt; pattern 2</code>: after 10 seconds,</li>
<li><code>pattern 2 &gt; pattern 1</code>: after 10 seconds, with a 70% chance,</li>
<li><code>pattern 2 &gt; pattern 3</code>: after 10 seconds, with a 30% chance,</li>
<li><code>pattern 3 &gt; waiting</code>: after 10 seconds or if the player is killed,</li>
<li><code>waiting &gt; pattern 1</code>: if there is only one (the boss itself) enemy on screen,</li>
<li><code>stunned &gt; pattern 1</code>: after 10 seconds,</li>
<li><code>dying &gt; (destroyed)</code>: after 5 seconds (we also want to play a dying sound effect),</li>
</ul>
<p>and the following transitions which will ignore the current state:</p>
<ul>
<li><code>(any) &gt; stunned</code>: the player has dealt at least 100 hit points of damage in a single second (we also want every enemy bullet on screen to disappear),</li>
<li><code>(any) &gt; dying</code>: the current hit points are 0 (we also want to destroy the enemy bullets).</li>
</ul>
<p>Finally we want to <em>delay</em> our state change for three seconds (so the bullets have some time to leave the screen), so we will add a fake <code>changing</code> state which behaves like this:</p>
<ul>
<li><code>(any) &gt; changing</code>: the boss will save the scheduled future state and won't shoot,</li>
<li><code>changing &gt; (scheduled state)</code>: the boss will actually perform the state change.</li>
</ul>
<p><strong>Note</strong>: the stunning condition we defined is simple to implement but not fair, some players will never be able to fire that many bullets in a short period of time (never triggering the <code>stunned</code> state), while others will be so fast the boss might become a sitting duck.</p>
<p>In general, one of the simplest ways to create a finite state machine is to use the <code>switch</code> construct in the following way:</p>
<pre><code>var update = function () {
    // update the time counter and other stimuli
    
    // Check for stimuli which will change the state ignoring the current one
    // (for example the &quot;dying&quot; state should be triggered when hp === 0,
    //  no matter which state is the current one).
    if (stimulus 0 is received) {
        // change to state &quot;state 4&quot;
    }

    // Handle each state.
    switch (this.state) {
        case &quot;state 1&quot;:
            // Behaviour corresponding to state 1
            
            // Check for stimuli which must be handled only when on state 1
            if (stimulus 1 is received) {
                // change state to &quot;state 2&quot;
            }
            else if (stimulus 2 is received) {
                // change state to &quot;state 3&quot;
            }
        break;
        case &quot;state 2&quot;:
            // Behaviour corresponding to state 2
            
            // Check for stimuli which must be handled only when on state 2
            if (stimulus 3 is received) {
                // change state to &quot;state 1&quot;
            }
            // etc.
        break;
        // etc.
     }
     
     // update logic common to each state (e.g. update the sprites or the position).
};
</code></pre>
<p>Let's apply this scheme to our update method (which will completely replace <a href="BHell.BHell_Enemy_Base.html#update"><code>BHell.BHell_Enemy_Base#update</code></a>, and therefore call only <a href="BHell.BHell_Sprite.html#update"><code>BHell.BHell_Sprite#update</code></a>):</p>
<pre><code>BHell_Enemy_Darklord.prototype.update = function () {
    my.BHell_Sprite.prototype.update.call(this);

    if (this.state !== &quot;dying&quot; &amp;&amp; this.state !== &quot;stunned&quot;) {
        this.move();
    }

    if (this.receivedDamage &gt; 100 &amp;&amp; this.mover.inPosition === true) {
        my.explosions.push(new my.BHell_Explosion(this.lastX, this.lastY, this.parent, my.explosions));
        this.changeState(&quot;stunned&quot;);
        my.controller.destroyEnemyBullets();
    }

    switch (this.state) {
        case &quot;started&quot;:
            if (this.mover.inPosition === true) {
                AudioManager.playSe({name: &quot;Monster5&quot;, volume: 100, pitch: 100, pan: 0});
                this.changeState(&quot;pattern 1&quot;);
            }
            break;
        case &quot;pattern 1&quot;: // Shoots from the hands and the claws for 10 seconds, then switches to pattern 2
            if (this.j &gt; 600) {
                this.changeState(&quot;pattern 2&quot;);
            } else {
                this.updateClaws();
                this.updateHands();
            }

            break;
        case &quot;pattern 2&quot;: // Shoots from the hands and the wings for 10 seconds, then switches randomly to pattern 1 or 3
            if (this.j &gt; 600) {
                if (Math.random() &gt; 0.7) {
                    this.changeState(&quot;pattern 3&quot;);
                }
                else {
                    this.changeState(&quot;pattern 1&quot;);
                }
            } else {
                this.updateWings();
                this.updateHands();
            }
            break;
        case &quot;pattern 3&quot;: // Spawns some probe enemies until the player dies or for 10 seconds.
            if (my.player.justSpawned || this.j &gt; 600) {
                this.changeState(&quot;waiting&quot;);
            }
            else {
                this.updateForehead();
            }

            break;
        case &quot;waiting&quot;: // Waits until there are no more enemies on screen.
            if (my.controller.enemies.length === 1) {
                this.changeState(&quot;pattern 1&quot;);
            }
            break;
        case &quot;stunned&quot;: // Does nothing for 10 seconds.
            if (this.j &gt; 600) {
                this.changeState(&quot;pattern 1&quot;);
            }
            break;
        case &quot;dying&quot;: // Spawns explosions for 5 seconds, then dies.
            if (this.j &gt; 300) {
                this.destroy();
            }
            else if (this.j % 10 === 0) {
                my.explosions.push(new my.BHell_Explosion(Math.floor(Math.random() * this.hitboxW) + this.x - this.hitboxW / 2, Math.floor(Math.random() * this.hitboxH) + this.y - this.hitboxH / 2, this.parent, my.explosions));
            }

            break;
        case &quot;changing&quot;: // Wait 3 seconds without shooting before actually changing to the scheduled state.
            if (this.j &gt; 180) {
                this.changeState(this.scheduledState);
            }
            break;
    }

    // Don't forget to update every emitter (including those not currently active),
    // otherwise they won't move with the boss!
    this.clawsEmitters.forEach(e =&gt; {
        e.update();
    });
    this.handsEmitters.forEach(e =&gt; {
        e.update();
    });
    this.wingsEmitters.forEach(e =&gt; {
        e.update();
    });

    // Update the received damage counter for the stunned state.
    if (this.j % 60 == 0) {
        this.receivedDamage = 0;
    }

    // Update the time counter and reset it every 20 seconds.
    this.j = (this.j + 1) % 1200;
};
</code></pre>
<p>The <code>update</code> method doesn't set the <code>dying</code> state, that's because we already have a method which is automatically invoked when the hit points reach zero.
Let's override our <a href="BHell.BHell_Enemy_Base.html#die"><code>BHell.BHell_Enemy_Base#die</code></a> method to change our boss' state:</p>
<pre><code>BHell_Enemy_Darklord.prototype.die = function() {
    $gameBHellResult.score += this.killScore;
    AudioManager.playSe({name:&quot;Collapse4&quot;, volume:100, pitch:100, pan:0});
    this.changeState(&quot;dying&quot;);

    my.controller.destroyEnemyBullets();
};
</code></pre>
<p>There is one final problem we need to deal with: our <code>stunned</code> state is triggered when <code>receivedDamage</code> reaches 100, but no method is currently updating that variable.
Let's override <a href="BHell.BHell_Enemy_Base.html#hit"><code>BHell.BHell_Enemy_Base#hit</code></a> (and while we are at it, let's make sure our boss won't receive any damage when it's <code>dying</code>):</p>
<pre><code>BHell_Enemy_Darklord.prototype.hit = function () {
    if (this.state !== &quot;dying&quot;) {
        my.BHell_Enemy_Base.prototype.hit.call(this);

        if (this.state != &quot;stunned&quot;) {
            this.receivedDamage++;
        }
    }
};
</code></pre>
<p>The <code>changeState</code> function takes care of correctly switching between states by turning off every emitter and resetting the time counter.
If the current state is <code>changing</code> it actually performs the state change, otherwise it stores the future state and then switches to <code>changing</code>.</p>
<pre><code>BHell_Enemy_Darklord.prototype.changeState = function(s) {
    if (this.state === &quot;changing&quot;) {
        this.state = s;
    }
    else {
        this.scheduledState = s;
        this.state = &quot;changing&quot;;
    }

    this.shoot(this.clawsEmitters, false);
    this.shoot(this.handsEmitters, false);
    this.shoot(this.wingsEmitters, false);

    this.j = 0;
    };
</code></pre>
<p>You may now understand why we implemented the emitters separately: by doing so, we only have to turn on the ones required for the current state, leaving every other one off, but if you carefully inspected the code, you noticed something odd about the <code>shoot</code> function: its signature (<a href="BHell.BHell_Enemy_Base.html#shoot"><code>BHell.BHell_Enemy_Base#shoot</code></a>) takes only one parameter!</p>
<p>The truth is that the <code>shoot</code> function implemented in <code>BHell_Enemy_Base</code> would fire from every emitter, something we don't want to happen, so let's reimplement it allowing us to choose from which emitter we want to shoot:</p>
<pre><code>BHell_Enemy_Darklord.prototype.shoot = function(emitters, t) {
    // Replaces BHell_Enemy_Base.shoot(t). It enables only SOME emitters at the time (not all of them).
    emitters.forEach(e =&gt; {
        e.shooting = t &amp;&amp; !my.player.justSpawned;
    });
}; 
</code></pre>
<h4>Putting the pieces together</h4>
<p>As usual, let's start by creating a new <code>darklord.js</code> plugin and by opening our <code>BHell</code> module:</p>
<pre><code>var BHell = (function (my) {    
    /* Our code will go here */
    
    return my;
}(BHell || {}));
</code></pre>
<p>And let's create a <code>BHell_Enemy_Darklord</code> class extending <a href="BHell.BHell_Enemy_Base.html"><code>BHell.BHell_Enemy_Base</code></a>:</p>
<pre><code>var BHell_Enemy_Darklord = my.BHell_Enemy_Darklord = function() {
    this.initialize.apply(this, arguments);
};

BHell_Enemy_Darklord.prototype = Object.create(my.BHell_Enemy_Base.prototype);
BHell_Enemy_Darklord.prototype.constructor = BHell_Enemy_Darklord;

BHell_Enemy_Darklord.prototype.initialize = function(x, y, image, params, parent, enemyList) {
    my.BHell_Enemy_Base.prototype.initialize.call(this, x, y, image, params, parent, enemyList);
};
</code></pre>
<p>We already wrote our <code>update</code> method, which handles our states in the way we want, and our auxiliary methods which are tailored for our needs.
All we need to do now is to initialise our boss. We have to:</p>
<ul>
<li>set some default parameters (for example hit points and speed),</li>
<li>initialise our emitters,</li>
<li>set the initial state,</li>
<li>set the mover.</li>
</ul>
<p>This is our initialisation method:</p>
<pre><code>BHell_Enemy_Darklord.prototype.initialize = function(x, y, image, params, parent, enemyList) {
    params.hp = 10000;
    params.speed = 0.3;
    params.hitbox_w = 399;
    params.hitbox_h = 350;
    params.animated = false;
    my.BHell_Enemy_Base.prototype.initialize.call(this, x, y, image, params, parent, enemyList);

    this.initializeForehead();
    this.initializeHands(parent);
    this.initializeClaws(parent);
    this.initializeWings(parent);

    this.j = 0;
    this.state = &quot;started&quot;;
    this.receivedDamage = 0;

    this.mover = new my.BHell_Mover_Bounce(Graphics.width / 2, 200, 0, this.hitboxW, this.hitboxH);
};
</code></pre>
<p>It looks like we have finished, but there is still one problem: if we test our class now, the emitters won't move with the boss!</p>
<p>By inspecting <a href="BHell.BHell_Enemy_Base.html#move"><code>BHell.BHell_Enemy_Base#move</code></a> we can easily spot the problem: that method moves only the emitters contained in <code>this.emitters</code>, but our emitters are divided into three arrays.
Let's fix this problem by rewriting the <code>move</code> method:</p>
<pre><code>BHell_Enemy_Darklord.prototype.move = function () {
    if (this.mover != null) {
        var p = this.mover.move(this.x, this.y, this.speed);
        this.x = p[0];
        this.y = p[1];
    }

    this.clawsEmitters.forEach(e =&gt; {
        e.move(this.x, this.y);
    });
    this.handsEmitters.forEach(e =&gt; {
        e.move(this.x, this.y);
    });
    this.wingsEmitters.forEach(e =&gt; {
        e.move(this.x, this.y);
    });
};
</code></pre>
<h4>The complete boss</h4>
<p>Our complete <code>BHell_Enemy_Darklord</code> class will look like this:</p>
<pre><code>var BHell = (function (my) {

    var BHell_Enemy_Darklord = my.BHell_Enemy_Darklord = function() {
        this.initialize.apply(this, arguments);
    };

    BHell_Enemy_Darklord.prototype = Object.create(my.BHell_Enemy_Base.prototype);
    BHell_Enemy_Darklord.prototype.constructor = BHell_Enemy_Darklord;

    BHell_Enemy_Darklord.prototype.initialize = function(x, y, image, params, parent, enemyList) {
        params.hp = 10000;
        params.speed = 0.3;
        params.hitbox_w = 399;
        params.hitbox_h = 350;
        params.animated = false;
        my.BHell_Enemy_Base.prototype.initialize.call(this, x, y, image, params, parent, enemyList);

        this.initializeForehead();
        this.initializeHands(parent);
        this.initializeClaws(parent);
        this.initializeWings(parent);

        this.j = 0;
        this.state = &quot;started&quot;;
        this.receivedDamage = 0;

        this.mover = new my.BHell_Mover_Bounce(Graphics.width / 2, 200, 0, this.hitboxW, this.hitboxH);
    };

    BHell_Enemy_Darklord.prototype.initializeForehead = function () {
        this.foreheadCounter = 0;
    };

    BHell_Enemy_Darklord.prototype.initializeHands = function (parent) {
        var handsParams = {};
        handsParams.bullet = {};
        handsParams.bullet.speed = 0.5;
        handsParams.bullet.index = 0;
        handsParams.bullet.frame = 0;
        handsParams.bullet.direction = 2;
        handsParams.period = 300;
        handsParams.a = 0;
        handsParams.b = 2 * Math.PI;
        handsParams.n = 45;
        this.handsEmitters = [];
        this.handsEmitters.push(new my.BHell_Emitter_Spray(0, 0, handsParams, parent, my.enemyBullets));
        this.handsEmitters.push(new my.BHell_Emitter_Spray(0, 0, handsParams, parent, my.enemyBullets));
        this.handsEmitters[0].offsetX = -46;
        this.handsEmitters[0].offsetY = -68;
        this.handsEmitters[1].offsetX = 100;
        this.handsEmitters[1].offsetY = -60;
    };

    BHell_Enemy_Darklord.prototype.initializeClaws = function (parent) {
        var clawsParams = {};
        clawsParams.bullet = {};
        clawsParams.bullet.speed = 1;
        clawsParams.bullet.index = 0;
        clawsParams.bullet.frame = 2;
        clawsParams.bullet.direction = 2;
        clawsParams.period = 5;
        clawsParams.a = Math.PI;
        clawsParams.b = 3 * Math.PI;
        clawsParams.n = 5;

        this.clawsEmitters = [];
        this.clawsEmitters.push(new my.BHell_Emitter_Spray(0, 0, clawsParams, parent, my.enemyBullets));
        this.clawsEmitters.push(new my.BHell_Emitter_Spray(0, 0, clawsParams, parent, my.enemyBullets));
        this.clawsEmitters[0].offsetX = -98;
        this.clawsEmitters[0].offsetY = 100;
        this.clawsEmitters[1].offsetX = 127;
        this.clawsEmitters[1].offsetY = 106;
        this.clawsCounter = 0;
    };

    BHell_Enemy_Darklord.prototype.initializeWings = function (parent) {
        var wingsParams = {};
        wingsParams.bullet = {};
        wingsParams.bullet.speed = 1;
        wingsParams.bullet.index = 0;
        wingsParams.bullet.frame = 2;
        wingsParams.bullet.direction = 8;
        wingsParams.period = 5;
        wingsParams.alwaysAim = true;
        wingsParams.aim = true;
        this.wingsEmitters = [];
        this.wingsEmitters.push(new my.BHell_Emitter_Angle(0, 0, wingsParams, parent, my.enemyBullets));
        this.wingsEmitters.push(new my.BHell_Emitter_Angle(0, 0, wingsParams, parent, my.enemyBullets));
        this.wingsEmitters[0].offsetX = 152;
        this.wingsEmitters[0].offsetY = -134;
        this.wingsEmitters[1].offsetX = -160;
        this.wingsEmitters[1].offsetY = -118;
        this.wingsEmitters[0].aimX = 100;
        this.wingsEmitters[0].alwaysAim = true;
        this.wingsEmitters[1].alwaysAim = true;
        this.wingsEmitters[1].aimX = -100;
    };


    BHell_Enemy_Darklord.prototype.update = function () {
        my.BHell_Sprite.prototype.update.call(this);

        if (this.state !== &quot;dying&quot; &amp;&amp; this.state !== &quot;stunned&quot;) {
            this.move();
        }

        if (this.receivedDamage &gt; 100 &amp;&amp; this.mover.inPosition === true) {
            my.explosions.push(new my.BHell_Explosion(this.lastX, this.lastY, this.parent, my.explosions));
            this.changeState(&quot;stunned&quot;);
            my.controller.destroyEnemyBullets();
        }

        switch (this.state) {
            case &quot;started&quot;:
                if (this.mover.inPosition === true) {
                    AudioManager.playSe({name: &quot;Monster5&quot;, volume: 100, pitch: 100, pan: 0});
                    this.changeState(&quot;pattern 1&quot;);
                }
                break;
            case &quot;pattern 1&quot;: // Shoots from the hands and the claws for 10 seconds, then switches to pattern 2
                if (this.j &gt; 600) {
                    this.changeState(&quot;pattern 2&quot;);
                } else {
                    this.updateClaws();
                    this.updateHands();
                }

                break;
            case &quot;pattern 2&quot;: // Shoots from the hands and the wings for 10 seconds, then switches randomly to pattern 1 or 3
                if (this.j &gt; 600) {
                    if (Math.random() &gt; 0.7) {
                        this.changeState(&quot;pattern 3&quot;);
                    }
                    else {
                        this.changeState(&quot;pattern 1&quot;);
                    }
                } else {
                    this.updateWings();
                    this.updateHands();
                }
                break;
            case &quot;pattern 3&quot;: // Spawns some probe enemies until the player dies or for 10 seconds.
                if (my.player.justSpawned || this.j &gt; 600) {
                    this.changeState(&quot;waiting&quot;);
                }
                else {
                    this.updateForehead();
                }

                break;
            case &quot;waiting&quot;: // Waits until there are no more enemies on screen.
                if (my.controller.enemies.length === 1) {
                    this.changeState(&quot;pattern 1&quot;);
                }
                break;
            case &quot;stunned&quot;: // Does nothing for 10 seconds.
                if (this.j &gt; 600) {
                    this.changeState(&quot;pattern 1&quot;);
                }
                break;
            case &quot;dying&quot;: // Spawns explosions for 5 seconds, then dies.
                if (this.j &gt; 300) {
                    this.destroy();
                }
                else if (this.j % 10 === 0) {
                    my.explosions.push(new my.BHell_Explosion(Math.floor(Math.random() * this.hitboxW) + this.x - this.hitboxW / 2, Math.floor(Math.random() * this.hitboxH) + this.y - this.hitboxH / 2, this.parent, my.explosions));
                }
                break;
            case &quot;changing&quot;: // Wait 3 seconds without shooting before actually changing to the scheduled state.
                if (this.j &gt; 180) {
                    this.changeState(this.scheduledState);
                }
                break;
        }

        this.clawsEmitters.forEach(e =&gt; {
            e.update();
        });
        this.handsEmitters.forEach(e =&gt; {
            e.update();
        });
        this.wingsEmitters.forEach(e =&gt; {
            e.update();
        });

        // Update the received damage counter for the stunned state.
        if (this.j % 60 == 0) {
            this.receivedDamage = 0;
        }

        // Update the time counter and reset it every 20 seconds.
        this.j = (this.j + 1) % 1200;
    };

    BHell_Enemy_Darklord.prototype.updateForehead = function() {
        // Spawn a probe enemy every 3 seconds.
        this.foreheadCounter = (this.foreheadCounter + 1) % 180;

        if (this.foreheadCounter === 0) {
            var image = {&quot;characterName&quot;:&quot;Evil&quot;,&quot;direction&quot;:2,&quot;pattern&quot;:0,&quot;characterIndex&quot;:6};
            var params = {};
            params.animated = true;
            params.aim = true;
            params.bullet = {};
            params.bullet.frame = 2;
            my.controller.enemies.push(new my.BHell_Enemy_Probe(this.x + 42, this.y - 82, image, params, this.parent, my.controller.enemies));
        }
    };

    BHell_Enemy_Darklord.prototype.updateHands = function() {
        this.shoot(this.handsEmitters, true);
    };

    BHell_Enemy_Darklord.prototype.updateWings = function() {
        this.shoot(this.wingsEmitters,true);
    };


    BHell_Enemy_Darklord.prototype.updateClaws = function() {
        if (this.clawsCounter === 0) {
            this.clawsEmitters[0].a = Math.PI;
            this.clawsEmitters[0].b = 3 * Math.PI;
            this.clawsEmitters[1].a = 0;
            this.clawsEmitters[1].b = 2 * Math.PI;
        }
        this.shoot(this.clawsEmitters, this.clawsCounter &lt; 180);

        this.clawsEmitters[0].a += 0.004;
        this.clawsEmitters[0].b += 0.004;
        this.clawsEmitters[1].a -= 0.004;
        this.clawsEmitters[1].b -= 0.004;

        this.clawsCounter = (this.clawsCounter + 1) % 300;
    };

    BHell_Enemy_Darklord.prototype.move = function () {
        if (this.mover != null) {
            var p = this.mover.move(this.x, this.y, this.speed);
            this.x = p[0];
            this.y = p[1];
        }

        this.clawsEmitters.forEach(e =&gt; {
            e.move(this.x, this.y);
        });
        this.handsEmitters.forEach(e =&gt; {
            e.move(this.x, this.y);
        });
        this.wingsEmitters.forEach(e =&gt; {
            e.move(this.x, this.y);
        });
    };


    BHell_Enemy_Darklord.prototype.shoot = function(emitters, t) {
        // Replaces BHell_Enemy_Base.shoot(t). It enables only SOME emitters at the time (not all of them).
        emitters.forEach(e =&gt; {
            e.shooting = t &amp;&amp; !my.player.justSpawned;
        });
    };

    BHell_Enemy_Darklord.prototype.changeState = function(s) {
        if (this.state === &quot;changing&quot;) {
            this.state = s;
        }
        else {
            this.scheduledState = s;
            this.state = &quot;changing&quot;;
        }

        this.shoot(this.clawsEmitters, false);
        this.shoot(this.handsEmitters, false);
        this.shoot(this.wingsEmitters, false);

        this.j = 0;
    };

    BHell_Enemy_Darklord.prototype.hit = function () {
        if (this.state !== &quot;dying&quot;) {
            my.BHell_Enemy_Base.prototype.hit.call(this);

            if (this.state != &quot;stunned&quot;) {
                this.receivedDamage++;
            }
        }
    };

    BHell_Enemy_Darklord.prototype.die = function() {
        $gameBHellResult.score += this.killScore;
        AudioManager.playSe({name:&quot;Collapse4&quot;, volume:100, pitch:100, pan:0});
        this.changeState(&quot;dying&quot;);

        my.controller.destroyEnemyBullets();
    };

    return my;
} (BHell || {}));
</code></pre>
<p><strong>Note</strong>: we didn't set anywhere in the code the <code>boss</code> flag, that's because the engine reads that flag from a <strong>generator</strong>, not a single enemy.</p>
<p>Like every other enemy, let's write the JSON entry:</p>
<pre><code>{
  &quot;name&quot;: &quot;darklord&quot;,
  &quot;class&quot;: &quot;BHell_Enemy_Darklord&quot;,
  &quot;params&quot;: {
    &quot;boss&quot;: true
  }
}
</code></pre>
<p>And finally let's create a generator for our boss:</p>
<p><img src="darklord_generator.png" alt="Darklord generator"></p>
<p><strong>Important</strong>: Remember that we positioned our emitters at coordinates corresponding to a very specific frame in our charset! If you plan to use this boss with a different appearance, you should change the emitter's coordinates as well.</p>
</article>

</section>

</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="BHell.html">BHell</a></li></ul><h3>Classes</h3><ul><li><a href="BHell.BHell_Bomb_Base.html">BHell_Bomb_Base</a></li><li><a href="BHell.BHell_Bomb_Earth.html">BHell_Bomb_Earth</a></li><li><a href="BHell.BHell_Bomb_Ice.html">BHell_Bomb_Ice</a></li><li><a href="BHell.BHell_Bomb_Water.html">BHell_Bomb_Water</a></li><li><a href="BHell.BHell_Bomb_Wind.html">BHell_Bomb_Wind</a></li><li><a href="BHell.BHell_Bullet.html">BHell_Bullet</a></li><li><a href="BHell.BHell_Controller.html">BHell_Controller</a></li><li><a href="BHell.BHell_Emitter_Angle.html">BHell_Emitter_Angle</a></li><li><a href="BHell.BHell_Emitter_Base.html">BHell_Emitter_Base</a></li><li><a href="BHell.BHell_Emitter_Burst.html">BHell_Emitter_Burst</a></li><li><a href="BHell.BHell_Emitter_Factory.html">BHell_Emitter_Factory</a></li><li><a href="BHell.BHell_Emitter_Rotate.html">BHell_Emitter_Rotate</a></li><li><a href="BHell.BHell_Emitter_Spray.html">BHell_Emitter_Spray</a></li><li><a href="BHell.BHell_Enemy_Base.html">BHell_Enemy_Base</a></li><li><a href="BHell.BHell_Enemy_Blocker.html">BHell_Enemy_Blocker</a></li><li><a href="BHell.BHell_Enemy_Burster.html">BHell_Enemy_Burster</a></li><li><a href="BHell.BHell_Enemy_Gunner.html">BHell_Enemy_Gunner</a></li><li><a href="BHell.BHell_Enemy_Gunner_Base.html">BHell_Enemy_Gunner_Base</a></li><li><a href="BHell.BHell_Enemy_Orbiter.html">BHell_Enemy_Orbiter</a></li><li><a href="BHell.BHell_Enemy_Probe.html">BHell_Enemy_Probe</a></li><li><a href="BHell.BHell_Enemy_Smallfry.html">BHell_Enemy_Smallfry</a></li><li><a href="BHell.BHell_Enemy_Spline.html">BHell_Enemy_Spline</a></li><li><a href="BHell.BHell_Enemy_Sprayer.html">BHell_Enemy_Sprayer</a></li><li><a href="BHell.BHell_Enemy_Starshooter.html">BHell_Enemy_Starshooter</a></li><li><a href="BHell.BHell_Enemy_Suicide.html">BHell_Enemy_Suicide</a></li><li><a href="BHell.BHell_Enemy_Swirler.html">BHell_Enemy_Swirler</a></li><li><a href="BHell.BHell_Explosion.html">BHell_Explosion</a></li><li><a href="BHell.BHell_Generator.html">BHell_Generator</a></li><li><a href="BHell.BHell_Mover_Base.html">BHell_Mover_Base</a></li><li><a href="BHell.BHell_Mover_Bounce.html">BHell_Mover_Bounce</a></li><li><a href="BHell.BHell_Mover_Chase.html">BHell_Mover_Chase</a></li><li><a href="BHell.BHell_Mover_Harmonic.html">BHell_Mover_Harmonic</a></li><li><a href="BHell.BHell_Mover_Orbit.html">BHell_Mover_Orbit</a></li><li><a href="BHell.BHell_Mover_Point.html">BHell_Mover_Point</a></li><li><a href="BHell.BHell_Mover_Spline.html">BHell_Mover_Spline</a></li><li><a href="BHell.BHell_Player.html">BHell_Player</a></li><li><a href="BHell.BHell_Sprite.html">BHell_Sprite</a></li><li><a href="BHell.BHell_Spriteset.html">BHell_Spriteset</a></li><li><a href="BHell.BHell_Window_BuyPlayers.html">BHell_Window_BuyPlayers</a></li><li><a href="BHell.BHell_Window_BuyUpgrades.html">BHell_Window_BuyUpgrades</a></li><li><a href="BHell.BHell_Window_Confirm.html">BHell_Window_Confirm</a></li><li><a href="BHell.BHell_Window_Pause.html">BHell_Window_Pause</a></li><li><a href="BHell.BHell_Window_Players.html">BHell_Window_Players</a></li><li><a href="BHell.BHell_Window_Preview.html">BHell_Window_Preview</a></li><li><a href="BHell.BHell_Window_Ranks.html">BHell_Window_Ranks</a></li><li><a href="BHell.BHell_Window_SelectPlayer.html">BHell_Window_SelectPlayer</a></li><li><a href="BHell.BHell_Window_ShopCommand.html">BHell_Window_ShopCommand</a></li><li><a href="BHell.BHell_Window_Status.html">BHell_Window_Status</a></li><li><a href="BHell.Scene_BHell.html">Scene_BHell</a></li><li><a href="BHell.Scene_BHell_Init.html">Scene_BHell_Init</a></li><li><a href="BHell.Scene_BHell_Shop.html">Scene_BHell_Shop</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-advanced.html">Advanced Topics</a></li><li><a href="tutorial-getting_started.html">Getting Started</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.2</a> on Wed Sep 18 2019 23:35:49 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>